# src/agent/state.py
"""
Modern State Management - Pure AI Trading Agent
ZERO BitQuery dependencies - Full compatibility with RugCheck + TweetScout + DexScreener
AI-driven analysis and judgment system
"""
from typing import List, Dict, Any, TypedDict, Optional
from datetime import datetime

class TokenData(TypedDict):
    """Modern token data structure - pure data collection + AI analysis"""
    
    # ============================================================================
    # CORE IDENTIFICATION
    # ============================================================================
    address: str                    # Token mint address
    symbol: str                     # Token symbol
    name: str                       # Token name
    
    # ============================================================================
    # RAW MARKET DATA (from DexScreener)
    # ============================================================================
    price_usd: float               # Current price in USD
    liquidity_usd: float           # Total liquidity in USD
    volume_24h: float              # 24h trading volume
    volume_1h: float               # 1h trading volume
    volume_5m: float               # 5m trading volume
    age_hours: float               # Token age in hours
    market_cap: float              # Market capitalization
    fdv: float                     # Fully diluted valuation
    
    # Raw price change data
    price_change_24h: float        # 24h price change %
    price_change_1h: float         # 1h price change %
    price_change_5m: float         # 5m price change %
    price_change_15m: float        # 15m price change %
    
    # Raw transaction data
    buy_count: int                 # Number of buy transactions
    sell_count: int                # Number of sell transactions
    buy_ratio: float               # Ratio of buys to total transactions
    total_transactions: int        # Total transaction count
    
    # DEX metadata
    pair_address: str              # Trading pair address
    dex_id: str                    # DEX identifier
    chain_id: str                  # Blockchain identifier
    url: str                       # DexScreener URL
    labels: List[str]              # Token labels/tags
    boosts_active: int             # Active boost count
    
    # ============================================================================
    # RAW SAFETY DATA (from RugCheck)
    # ============================================================================
    safety_raw_data: Dict[str, Any]    # Complete raw RugCheck response
    
    # Key safety indicators (extracted from raw data)
    contract_verified: bool        # Contract verification status
    liquidity_locked: bool         # Liquidity lock status
    ownership_concentration: float # Token ownership concentration %
    honeypot_risk: bool           # Honeypot risk detected
    rug_pull_risk: bool           # Rug pull risk detected
    risk_factors: List[Dict[str, Any]]  # List of detected risk factors
    
    # ============================================================================
    # RAW SOCIAL DATA (from TweetScout)  
    # ============================================================================
    social_raw_data: Dict[str, Any]     # Complete raw TweetScout response
    
    # Key social indicators (extracted from raw data)
    social_mentions_24h: int       # Social mentions in 24h
    total_engagement: int          # Total social engagement
    unique_users: int              # Unique users discussing token
    verified_accounts: int         # Verified accounts mentioning token
    trending_potential: bool       # Trending potential detected
    
    # ============================================================================
    # RAW WHALE DATA (enhanced from DEX data)
    # ============================================================================
    whale_raw_data: Dict[str, Any]      # Whale analysis data
    
    # Key whale indicators
    large_transactions_detected: bool   # Large transactions present
    average_transaction_size: float     # Average transaction size USD
    whale_dominance_score: float       # Whale activity dominance
    
    # ============================================================================
    # AI ANALYSIS RESULTS (Generated by Claude)
    # ============================================================================
    ai_overall_score: float        # AI-calculated overall score 0-100
    ai_recommendation: str         # AI trading recommendation
    ai_risk_assessment: str        # AI risk level assessment
    ai_reasoning: str              # AI reasoning for decisions
    ai_confidence: float           # AI confidence in analysis 0-100
    ai_market_context: str         # AI market context analysis
    
    # Detailed AI scores
    ai_safety_score: float         # AI-interpreted safety score
    ai_social_score: float         # AI-interpreted social score
    ai_whale_score: float          # AI-interpreted whale activity score
    ai_momentum_score: float       # AI-calculated momentum score
    ai_viral_potential: float      # AI-assessed viral potential
    
    # ============================================================================
    # ENRICHMENT METADATA
    # ============================================================================
    enriched: bool                 # Token has been enriched with additional data
    enrichment_quality: str        # Quality level: 'excellent', 'good', 'partial', 'basic'
    enrichment_timestamp: str      # When enrichment was performed
    data_sources_used: Dict[str, bool]  # Which data sources were successfully used
    
    # Data collection timestamps
    dexscreener_timestamp: str     # When DexScreener data was collected
    rugcheck_timestamp: str        # When RugCheck data was collected
    tweetscout_timestamp: str      # When TweetScout data was collected
    
    # Legacy compatibility (for gradual migration)
    enriched_legacy: bool          # For compatibility with existing UI components
    
class Position(TypedDict):
    """Modern position data structure - AI-driven position management"""
    
    # ============================================================================
    # CORE POSITION DATA
    # ============================================================================
    token_address: str             # Token mint address
    token_symbol: str              # Token symbol
    token_name: str                # Token name
    position_id: str               # Unique position identifier
    
    # Entry data
    entry_price_usd: float         # Entry price in USD
    entry_time: str                # Entry timestamp ISO format
    amount: float                  # Token amount held
    position_size_sol: float       # Position size in SOL
    entry_value_usd: float         # Entry value in USD
    
    # Current data
    current_price_usd: float       # Current token price
    current_value_usd: float       # Current position value
    current_value_sol: float       # Current position value in SOL
    current_profit_percentage: float  # Current profit/loss %
    unrealized_pnl_usd: float      # Unrealized P&L in USD
    unrealized_pnl_sol: float      # Unrealized P&L in SOL
    
    # Time tracking
    hold_time_hours: float         # How long position has been held
    position_age_hours: float      # Alias for hold_time_hours
    
    # ============================================================================
    # ENTRY ANALYSIS DATA (AI analysis at time of entry)
    # ============================================================================
    entry_ai_analysis: Dict[str, Any]     # Complete AI analysis at entry
    
    # Key entry metrics (for quick access)
    entry_ai_score: float          # AI overall score at entry
    entry_ai_recommendation: str   # AI recommendation at entry
    entry_ai_reasoning: str        # AI reasoning at entry
    entry_confidence: float        # AI confidence at entry
    
    # Entry market data snapshot
    entry_safety_score: float      # Safety score at entry
    entry_social_score: float      # Social score at entry
    entry_viral_score: float       # Viral potential at entry
    entry_whale_activity: float    # Whale activity at entry
    entry_market_conditions: Dict[str, Any]  # Market conditions at entry
    
    # ============================================================================
    # POSITION MANAGEMENT
    # ============================================================================
    reason: str                    # Reason for entering position
    strategy: str                  # Trading strategy used
    target_profit_percentage: float    # Target profit %
    stop_loss_percentage: float        # Stop loss %
    max_hold_time_hours: float         # Maximum hold time
    
    # Risk management
    risk_level: str                # Risk level: 'low', 'medium', 'high', 'critical'
    position_weight: float         # Position weight in portfolio %
    
    # Exit criteria (AI-determined)
    ai_exit_signals: List[str]     # Current AI exit signals
    ai_hold_recommendation: str    # Current AI hold/exit recommendation
    ai_updated_reasoning: str      # Latest AI reasoning update
    
    # ============================================================================
    # PERFORMANCE TRACKING
    # ============================================================================
    peak_profit_percentage: float  # Peak profit achieved
    max_drawdown_percentage: float # Maximum drawdown experienced
    profit_target_hit: bool        # Whether profit target was reached
    stop_loss_triggered: bool      # Whether stop loss was triggered
    
    # ============================================================================
    # ENRICHMENT AND METADATA
    # ============================================================================
    enriched: bool                 # Position data enriched with analysis
    last_update_timestamp: str     # Last position update
    data_sources_used: Dict[str, bool]  # Data sources used for this position
    
    # Legacy compatibility
    bitquery_enriched: bool        # For compatibility (always False now)

class AgentState(TypedDict):
    """Modern agent state - Pure AI trading system"""
    
    # ============================================================================
    # PORTFOLIO STATE
    # ============================================================================
    wallet_balance_sol: float      # Current SOL balance
    wallet_balance_usd: float      # Current USD equivalent balance
    active_positions: List[Position]       # Currently held positions
    total_portfolio_value_sol: float       # Total portfolio value in SOL
    total_portfolio_value_usd: float       # Total portfolio value in USD
    
    # ============================================================================
    # TOKEN DISCOVERY AND ANALYSIS
    # ============================================================================
    discovered_tokens: List[TokenData]     # Newly discovered tokens (raw)
    analyzed_tokens: List[TokenData]       # Tokens with AI analysis completed
    validated_tokens: List[TokenData]      # Tokens validated for potential trading
    watchlist_tokens: List[TokenData]      # Tokens being monitored
    
    # ============================================================================
    # TRADING DECISIONS AND EXECUTION
    # ============================================================================
    trading_decisions: List[Dict[str, Any]]    # AI trading decisions made
    pending_orders: List[Dict[str, Any]]       # Orders waiting for execution
    transaction_history: List[Dict[str, Any]]  # Completed transactions
    failed_transactions: List[Dict[str, Any]]  # Failed transaction attempts
    
    # ============================================================================
    # MARKET ANALYSIS
    # ============================================================================
    market_conditions: Dict[str, Any]     # Current market analysis
    ai_market_assessment: Dict[str, Any]  # AI's market assessment
    market_sentiment: str                 # Overall market sentiment
    trend_analysis: Dict[str, Any]        # Trend analysis data
    
    # ============================================================================
    # AI AGENT STATE
    # ============================================================================
    agent_reasoning: str           # Latest AI reasoning/thought process
    ai_confidence_level: float     # AI confidence in current strategy
    ai_strategy: str              # Current AI trading strategy
    ai_focus_areas: List[str]     # Areas AI is currently focusing on
    ai_learned_patterns: List[Dict[str, Any]]  # Patterns AI has learned
    
    # Agent execution state
    current_cycle_stage: str      # Current stage in trading cycle
    next_action: str             # Next planned action
    cycle_start_time: str        # When current cycle started
    cycles_completed: int        # Number of completed cycles
    
    # ============================================================================
    # AGENT CONFIGURATION
    # ============================================================================
    agent_parameters: Dict[str, Any]      # Agent configuration parameters
    trading_mode: str             # 'live', 'dry_run', 'simulation'
    risk_management: Dict[str, Any]       # Risk management settings
    
    # Core trading parameters
    max_positions: int            # Maximum concurrent positions
    max_position_size_sol: float  # Maximum position size in SOL
    min_position_size_sol: float  # Minimum position size in SOL
    portfolio_allocation: Dict[str, float]  # Portfolio allocation strategy
    
    # ============================================================================
    # PERFORMANCE METRICS
    # ============================================================================
    portfolio_metrics: Dict[str, Any]     # Portfolio performance metrics
    trading_performance: Dict[str, Any]   # Trading performance statistics
    ai_performance: Dict[str, Any]        # AI decision performance metrics
    
    # Key performance indicators
    total_profit_sol: float       # Total profit in SOL
    total_profit_usd: float       # Total profit in USD
    win_rate: float              # Percentage of profitable trades
    sharpe_ratio: float          # Risk-adjusted returns
    max_drawdown: float          # Maximum portfolio drawdown
    
    # Trade statistics
    total_trades: int            # Total number of trades
    successful_trades: int       # Number of profitable trades
    average_hold_time: float     # Average position hold time
    average_profit_per_trade: float  # Average profit per trade
    
    # ============================================================================
    # LEARNING AND MEMORY
    # ============================================================================
    ai_memory_stats: Dict[str, Any]       # AI memory/learning statistics
    pattern_recognition: Dict[str, Any]   # Recognized market patterns
    strategy_evolution: List[Dict[str, Any]]  # How strategy has evolved
    
    # Historical analysis
    successful_strategies: List[str]      # Strategies that worked well
    failed_strategies: List[str]         # Strategies that failed
    market_lessons_learned: List[str]    # Lessons learned from market
    
    # ============================================================================
    # SYSTEM STATE
    # ============================================================================
    last_update_timestamp: str    # Last state update timestamp
    agent_health: Dict[str, Any]  # Agent system health status
    data_source_status: Dict[str, Any]    # Status of data sources
    execution_status: Dict[str, Any]     # Trading execution status
    
    # API and service status
    rugcheck_status: Dict[str, Any]      # RugCheck API status
    tweetscout_status: Dict[str, Any]    # TweetScout API status
    dexscreener_status: Dict[str, Any]   # DexScreener API status
    solana_rpc_status: Dict[str, Any]    # Solana RPC status
    vector_store_status: Dict[str, Any]  # Vector store status
    
    # ============================================================================
    # DEBUGGING AND MONITORING
    # ============================================================================
    debug_info: Dict[str, Any]    # Debug information
    error_log: List[Dict[str, Any]]       # Error log
    performance_log: List[Dict[str, Any]] # Performance log
    
    # Cycle tracking
    recursion_counter: int        # Safety counter for recursive calls
    max_recursion_limit: int      # Maximum allowed recursion depth
    
    # Legacy compatibility fields (for gradual UI migration)
    bitquery_status: Dict[str, Any]       # Empty dict for compatibility
    enhanced_analytics: Dict[str, Any]    # Renamed from bitquery analytics


def create_initial_state() -> AgentState:
    """Create the initial modern agent state"""
    from src.blockchain.solana_client import get_wallet_balance
    
    current_time = datetime.now().isoformat()
    wallet_balance = get_wallet_balance()
    
    return AgentState(
        # Portfolio state
        wallet_balance_sol=wallet_balance,
        wallet_balance_usd=0.0,  # Will be calculated
        active_positions=[],
        total_portfolio_value_sol=wallet_balance,
        total_portfolio_value_usd=0.0,
        
        # Token discovery
        discovered_tokens=[],
        analyzed_tokens=[],
        validated_tokens=[],
        watchlist_tokens=[],
        
        # Trading
        trading_decisions=[],
        pending_orders=[],
        transaction_history=[],
        failed_transactions=[],
        
        # Market analysis
        market_conditions={},
        ai_market_assessment={},
        market_sentiment="neutral",
        trend_analysis={},
        
        # AI agent state
        agent_reasoning="Initializing pure AI trading agent...",
        ai_confidence_level=50.0,
        ai_strategy="discovery_and_analysis",
        ai_focus_areas=["token_discovery", "market_analysis"],
        ai_learned_patterns=[],
        
        # Execution state
        current_cycle_stage="initialization",
        next_action="discover_tokens",
        cycle_start_time=current_time,
        cycles_completed=0,
        
        # Configuration
        agent_parameters={
            "trading_mode": "dry_run",
            "max_positions": 5,
            "max_position_size_sol": 0.1,
            "min_position_size_sol": 0.01,
            "risk_tolerance": "medium",
            "ai_temperature": 0.1,
            "cycle_time_seconds": 300,
            "enable_learning": True,
            "enable_memory": True
        },
        trading_mode="dry_run",
        risk_management={
            "max_portfolio_risk": 0.15,
            "max_position_risk": 0.05,
            "stop_loss_threshold": -15.0,
            "take_profit_threshold": 25.0,
            "max_hold_time_hours": 24.0
        },
        max_positions=5,
        max_position_size_sol=0.1,
        min_position_size_sol=0.01,
        portfolio_allocation={
            "cash": 0.7,
            "positions": 0.3
        },
        
        # Performance metrics
        portfolio_metrics={
            "total_value_sol": wallet_balance,
            "unrealized_profit_sol": 0.0,
            "realized_profit_sol": 0.0,
            "daily_pnl": 0.0,
            "win_rate": 0.0,
            "last_updated": current_time
        },
        trading_performance={},
        ai_performance={},
        total_profit_sol=0.0,
        total_profit_usd=0.0,
        win_rate=0.0,
        sharpe_ratio=0.0,
        max_drawdown=0.0,
        total_trades=0,
        successful_trades=0,
        average_hold_time=0.0,
        average_profit_per_trade=0.0,
        
        # Learning and memory
        ai_memory_stats={},
        pattern_recognition={},
        strategy_evolution=[],
        successful_strategies=[],
        failed_strategies=[],
        market_lessons_learned=[],
        
        # System state
        last_update_timestamp=current_time,
        agent_health={"status": "healthy", "last_check": current_time},
        data_source_status={},
        execution_status={"status": "ready"},
        rugcheck_status={},
        tweetscout_status={},
        dexscreener_status={},
        solana_rpc_status={},
        vector_store_status={},
        
        # Debugging
        debug_info={},
        error_log=[],
        performance_log=[],
        recursion_counter=0,
        max_recursion_limit=10,
        
        # Legacy compatibility
        bitquery_status={},  # Empty for compatibility
        enhanced_analytics={}
    )

def update_portfolio_metrics(state: AgentState) -> AgentState:
    """Update portfolio performance metrics"""
    try:
        # Calculate current portfolio value
        active_positions = state.get("active_positions", [])
        wallet_balance = state.get("wallet_balance_sol", 0)
        
        total_position_value = sum(pos.get("current_value_sol", 0) for pos in active_positions)
        total_portfolio_value = wallet_balance + total_position_value
        
        # Calculate unrealized P&L
        unrealized_pnl = sum(pos.get("unrealized_pnl_sol", 0) for pos in active_positions)
        
        # Update state
        state["total_portfolio_value_sol"] = total_portfolio_value
        state["portfolio_metrics"]["total_value_sol"] = total_portfolio_value
        state["portfolio_metrics"]["unrealized_profit_sol"] = unrealized_pnl
        state["portfolio_metrics"]["last_updated"] = datetime.now().isoformat()
        
        # Calculate win rate
        transaction_history = state.get("transaction_history", [])
        completed_trades = [tx for tx in transaction_history if tx.get("type") in ["sell", "partial_sell"]]
        if completed_trades:
            profitable_trades = [tx for tx in completed_trades if tx.get("profit_percentage", 0) > 0]
            win_rate = len(profitable_trades) / len(completed_trades)
            state["win_rate"] = win_rate
            state["portfolio_metrics"]["win_rate"] = win_rate
        
        return state
        
    except Exception as e:
        import logging
        logger = logging.getLogger("trading_agent.state")
        logger.error(f"Error updating portfolio metrics: {e}")
        return state

def save_agent_state(state: AgentState, filename: str = "agent_state.json") -> bool:
    """Save the modern agent state to disk"""
    import json
    import logging
    
    logger = logging.getLogger("trading_agent.state")
    
    try:
        # Update metrics before saving
        state = update_portfolio_metrics(state)
        
        # Convert state to serializable dict
        serializable_state = {
            # Core portfolio data
            "wallet_balance_sol": state.get("wallet_balance_sol", 0),
            "active_positions": state.get("active_positions", []),
            "transaction_history": state.get("transaction_history", []),
            
            # Analysis data
            "analyzed_tokens": state.get("analyzed_tokens", []),
            "validated_tokens": state.get("validated_tokens", []),
            "market_conditions": state.get("market_conditions", {}),
            
            # AI state
            "agent_reasoning": state.get("agent_reasoning", ""),
            "ai_strategy": state.get("ai_strategy", ""),
            "ai_learned_patterns": state.get("ai_learned_patterns", []),
            
            # Configuration
            "agent_parameters": state.get("agent_parameters", {}),
            "risk_management": state.get("risk_management", {}),
            
            # Performance
            "portfolio_metrics": state.get("portfolio_metrics", {}),
            "trading_performance": state.get("trading_performance", {}),
            
            # System state
            "last_update_timestamp": datetime.now().isoformat(),
            "cycles_completed": state.get("cycles_completed", 0),
            
            # Legacy compatibility
            "market_conditions": state.get("market_conditions", {}),  # For UI compatibility
        }
        
        # Save to file
        with open(filename, "w") as f:
            json.dump(serializable_state, f, indent=2)
            
        logger.info(f"Agent state saved successfully to {filename}")
        return True
        
    except Exception as e:
        logger.error(f"Error saving agent state: {e}")
        return False

def load_agent_state(filename: str = "agent_state.json") -> Optional[AgentState]:
    """Load the modern agent state from disk"""
    import json
    import os
    import logging
    
    logger = logging.getLogger("trading_agent.state")
    
    try:
        if os.path.exists(filename):
            with open(filename, "r") as f:
                data = json.load(f)
            
            logger.info(f"Agent state loaded from {filename}")
            return data
        else:
            logger.info(f"No saved state found at {filename}, will create new state")
            return None
            
    except Exception as e:
        logger.error(f"Error loading agent state: {e}")
        return None

def migrate_legacy_state(legacy_state: Dict[str, Any]) -> AgentState:
    """
    Migrate legacy BitQuery-based state to modern structure
    """
    import logging
    logger = logging.getLogger("trading_agent.state")
    
    try:
        # Create new state
        new_state = create_initial_state()
        
        # Migrate basic portfolio data
        if "wallet_balance" in legacy_state:
            new_state["wallet_balance_sol"] = legacy_state["wallet_balance"]
            
        # Migrate positions (remove BitQuery fields)
        if "active_positions" in legacy_state:
            migrated_positions = []
            for pos in legacy_state["active_positions"]:
                migrated_pos = {
                    # Core data
                    "token_address": pos.get("token_address", ""),
                    "token_symbol": pos.get("token_symbol", ""),
                    "token_name": pos.get("token_name", ""),
                    "position_id": f"pos_{len(migrated_positions)}",
                    
                    # Entry data
                    "entry_price_usd": pos.get("entry_price_usd", 0),
                    "entry_time": pos.get("entry_time", datetime.now().isoformat()),
                    "amount": pos.get("amount", 0),
                    "position_size_sol": pos.get("position_size_sol", 0),
                    "entry_value_usd": pos.get("entry_value_usd", 0),
                    
                    # Current data
                    "current_price_usd": pos.get("current_price_usd", 0),
                    "current_value_usd": pos.get("current_value_usd", 0),
                    "current_value_sol": pos.get("current_value_sol", 0),
                    "current_profit_percentage": pos.get("current_profit_percentage", 0),
                    "unrealized_pnl_usd": pos.get("unrealized_pnl_usd", 0),
                    "unrealized_pnl_sol": pos.get("unrealized_pnl_sol", 0),
                    
                    # Time tracking
                    "hold_time_hours": pos.get("hold_time_hours", 0),
                    "position_age_hours": pos.get("hold_time_hours", 0),
                    
                    # Entry analysis (convert from BitQuery to AI format)
                    "entry_ai_analysis": {},
                    "entry_ai_score": pos.get("entry_bitquery_score", 0),
                    "entry_ai_recommendation": pos.get("entry_bitquery_recommendation", "UNKNOWN"),
                    "entry_ai_reasoning": "Migrated from legacy system",
                    "entry_confidence": 50.0,
                    
                    # Other fields with defaults
                    "reason": pos.get("reason", "Legacy position"),
                    "strategy": "legacy",
                    "risk_level": "medium",
                    "enriched": pos.get("bitquery_enriched", False),
                    "last_update_timestamp": datetime.now().isoformat(),
                    "data_sources_used": {"legacy": True},
                    "bitquery_enriched": False,  # Always False now
                    
                    # Initialize other required fields
                    "entry_safety_score": 0,
                    "entry_social_score": 0, 
                    "entry_viral_score": 0,
                    "entry_whale_activity": 0,
                    "entry_market_conditions": {},
                    "target_profit_percentage": 25.0,
                    "stop_loss_percentage": -15.0,
                    "max_hold_time_hours": 24.0,
                    "position_weight": 0.0,
                    "ai_exit_signals": [],
                    "ai_hold_recommendation": "HOLD",
                    "ai_updated_reasoning": "",
                    "peak_profit_percentage": 0.0,
                    "max_drawdown_percentage": 0.0,
                    "profit_target_hit": False,
                    "stop_loss_triggered": False
                }
                migrated_positions.append(migrated_pos)
            
            new_state["active_positions"] = migrated_positions
        
        # Migrate other legacy fields
        if "transaction_history" in legacy_state:
            new_state["transaction_history"] = legacy_state["transaction_history"]
            
        if "market_conditions" in legacy_state:
            new_state["market_conditions"] = legacy_state["market_conditions"]
            
        if "agent_parameters" in legacy_state:
            new_state["agent_parameters"].update(legacy_state["agent_parameters"])
            
        logger.info("Successfully migrated legacy state to modern format")
        return new_state
        
    except Exception as e:
        logger.error(f"Error migrating legacy state: {e}")
        return create_initial_state()

def validate_state_structure(state: AgentState) -> bool:
    """Validate that state has required modern structure"""
    required_fields = [
        "wallet_balance_sol", "active_positions", "agent_reasoning",
        "ai_strategy", "portfolio_metrics", "agent_parameters"
    ]
    
    for field in required_fields:
        if field not in state:
            return False
    
    return True

def get_state_summary(state: AgentState) -> Dict[str, Any]:
    """Get a summary of current state for logging/debugging"""
    return {
        "wallet_balance_sol": state.get("wallet_balance_sol", 0),
        "active_positions_count": len(state.get("active_positions", [])),
        "total_portfolio_value": state.get("total_portfolio_value_sol", 0),
        "ai_strategy": state.get("ai_strategy", "unknown"),
        "cycles_completed": state.get("cycles_completed", 0),
        "win_rate": state.get("win_rate", 0),
        "total_trades": state.get("total_trades", 0),
        "last_updated": state.get("last_update_timestamp", ""),
        "current_stage": state.get("current_cycle_stage", "unknown")
    }